#pragma once

#include "tchar.h"
#include "windows.h"
#include <string>
#include <GL/glew.h>

namespace QymEngine {

	enum VertexAttributeLocation
	{
		VERTEX_ATTRIBUTE_LOCATION_POSITION = 0,
		VERTEX_ATTRIBUTE_LOCATION_COLOR = 1,
		VERTEX_ATTRIBUTE_LOCATION_UV0 = 2,
		VERTEX_ATTRIBUTE_LOCATION_UV1 = 3,
	};

	enum class E_INTERSECTION_DETECTION_MODE
	{
		AABB,
		OBB
	};

	const GLint DEFAULT_FRAMEBUFFER_SIZE = 512;

	const char globe_shader_vs[] =
		"\n"
		"#version 420\n"
		"\n"
		"in vec3 Position;\n"
		"in vec2 TexCoord;\n"
		"uniform mat4 Mvpm;\n"
		"uniform mat4 Texm;\n"
		"\n"
		"out vec2 tex_coord;\n"
		"\n"
		"void main( void )\n"
		"{\n"
		"	vec4 outPos = Mvpm * vec4(Position, 1.0);\n"
		//"	vec4 outPos = vec4(Position.xy, 0.0, 1.0);\n"
		"	tex_coord = (Texm * vec4(TexCoord, 0.0, 1.0)).xy;\n"
		//"	tex_coord = TexCoord;\n"
		"	gl_Position = outPos;\n"
		"}\n"
		;

	const char globe_shader_fs[] =
		"\n"
		"#version 420\n"
		"\n"
		"uniform sampler2D Texture0;\n"
		"\n"
		"in vec2 tex_coord;\n"
		"\n"
		"void main(void)\n"
		"{\n"
		"	gl_FragColor = texture2D(Texture0, tex_coord);\n"
		//"	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
		"\n"
		"}\n"
		;

	const char warp_shader_vs[] =
		"\n"
		"#version 420\n"
		"\n"
		"in vec3 Position;\n"
		"in vec2 TexCoord;\n"
		"\n"
		"out vec2 tex_coord;\n"
		"\n"
		"void main( void )\n"
		"{\n"
		"	vec4 outPos = vec4(Position, 1.0);\n"
		"	tex_coord = TexCoord;\n"
		"	gl_Position = outPos;\n"
		"}\n"
		;

	const char warp_shader_fs[] =
		"\n"
		"#version 420\n"
		"\n"
		"uniform sampler2D Texture0;\n"
		"uniform sampler2D Texture1;\n"
		"uniform sampler2D Texture2;\n"
		"\n"
		"in vec2 tex_coord;\n"
		"\n"
		"float getFloat(vec4 cood)\n"
		"{\n"
		"	vec4 f = cood.rgba;\n"
		"	int i = 0;\n"
		"	i += int(f.x * 255);\n"
		"	i *= 100;\n"
		"	i += int(f.y * 255);\n"
		"	i *= 100;\n"
		"	i += int(f.z * 255);\n"
		"	i *= 10;\n"
		"	i += int(f.w * 255);\n"
		"	return (float(i)) / 10000000;\n"
		"\n"
		"}\n"
		"void main(void)\n"
		"{\n"
		"	vec4 coodU = texture2D(Texture1, tex_coord);\n"
		"	vec4 coodV = texture2D(Texture2, tex_coord);\n"
		"\n"
		"	float realU = getFloat(coodU);\n"
		"	float realV = getFloat(coodV);\n"
		"\n"
		"	vec4 output;\n"
		"	if (realU > 1.0 && realV > 1.0) { \n"
		"		output = vec4(0.0, 0.0, 0.0, 0.0);\n"
		"	}\n"
		"	else {\n"
		"		vec2 uv = vec2(realU, realV);\n"
		"		output = texture2D(Texture0, uv);\n"
		//"		output = vec4(realV, realV, realV, 1.0f);\n"
		"	}\n"
		"	gl_FragColor = output;\n"
		//"	gl_FragColor = texture2D(Texture0, tex_coord);\n"
		"\n"
		"}\n"
		;

	//const char warp_shader_fs[] =
	//	"\n"
	//	"#version 420\n"
	//	"\n"
	//	"uniform sampler2D Texture0;\n"
	//	"uniform sampler2D Texture1;\n"
	//	"uniform sampler2D Texture2;\n"
	//	"uniform sampler2D Texture3;\n"
	//	"uniform sampler2D Texture4;\n"
	//	"uniform sampler2D Texture5;\n"
	//	"uniform sampler2D Texture6;\n"
	//	"\n"
	//	"in vec2 tex_coord;\n"
	//	"\n"
	//	"float getFloat(vec4 cood)\n"
	//	"{\n"
	//	"	vec4 f = cood.rgba;\n"
	//	"	int i = 0;\n"
	//	"	i += int(f.x * 255);\n"
	//	"	i *= 100;\n"
	//	"	i += int(f.y * 255);\n"
	//	"	i *= 100;\n"
	//	"	i += int(f.z * 255);\n"
	//	"	i *= 10;\n"
	//	"	i += int(f.w * 255);\n"
	//	"	return (float(i)) / 10000000;\n"
	//	"\n"
	//	"}\n"
	//	"void main(void)\n"
	//	"{\n"
	//	"	vec4 coodU1 = texture2D(Texture1, tex_coord);\n"
	//	"	vec4 coodV1 = texture2D(Texture2, tex_coord);\n"
	//	"	vec4 coodA1 = texture2D(Texture3, tex_coord);\n"
	//	"	vec4 coodU2 = texture2D(Texture4, tex_coord);\n"
	//	"	vec4 coodV2 = texture2D(Texture5, tex_coord);\n"
	//	"	vec4 coodA2 = texture2D(Texture6, tex_coord);\n"
	//	"\n"
	//	"	float realU1 = getFloat(coodU1);\n"
	//	"	float realV1 = getFloat(coodV1);\n"
	//	"	float realA1 = getFloat(coodA1);\n"
	//	"	float realU2 = getFloat(coodU2);\n"
	//	"	float realV2 = getFloat(coodV2);\n"
	//	"	float realA2 = getFloat(coodA2);\n"
	//	"\n"
	//	"	vec4 output;\n"
	//	"	vec4 output1;\n"
	//	"	vec4 output2;\n"
	//	"	if (realU1 > 1.0 && realV1 > 1.0 && realA1 > 1.0 &&"
	//	"		realU2 > 1.0 && realV2 > 1.0 && realA2 > 1.0)"
	//	"	{ \n"
	//	"		output = vec4(0.0, 0.0, 0.0, 0.0);\n"
	//	"	}\n"
	//	"	else {\n"
	//	"		vec2 uv1 = vec2(realU1, realV1);\n"
	//	"		vec2 uv2 = vec2(realU2, realV2);\n"
	//	"		output1 = texture2D(Texture0, uv1);\n"
	//	"		output2 = texture2D(Texture0, uv2);\n"
	//	"		output = output1 * realA1 + output2 * realA2;\n"
	//	//"		output = vec4(realV, realV, realV, 1.0f);\n"
	//	"	}\n"
	//	"	gl_FragColor = output;\n"
	//	//"	gl_FragColor = texture2D(Texture0, tex_coord);\n"
	//	"\n"
	//	"}\n"
	//	;

	const char normal_shader_vs[] =
		"\n"
		"#version 420\n"
		"\n"
		"in vec3 Position;\n"
		"in vec2 TexCoord;\n"
		"\n"
		"out vec2 tex_coord;\n"
		"\n"
		"void main( void )\n"
		"{\n"
		"	vec4 outPos = vec4(Position, 1.0);\n"
		"	tex_coord = TexCoord;\n"
		"	gl_Position = outPos;\n"
		"}\n"
		;

	const char normal_shader_fs[] =
		"\n"
		"#version 420\n"
		"\n"
		"uniform sampler2D Texture0;\n"
		"\n"
		"in vec2 tex_coord;\n"
		"\n"
		"void main(void)\n"
		"{\n"
		"	gl_FragColor = texture2D(Texture0, tex_coord);\n"
		"\n"
		"}\n"
		;

	const char lookup_table_shader_vs[] =
		"\n"
		"#version 430\n"
		"\n"
		"in vec3 Position;\n"
		"in vec2 TexCoord;\n"
		"\n"
		"out vec2 tex_coord;\n"
		"\n"
		"void main( void )\n"
		"{\n"
		"	vec4 outPos = vec4(Position, 1.0);\n"
		"	tex_coord = TexCoord;\n"
		"	gl_Position = outPos;\n"
		"}\n"
		;

	const char lookup_table_shader_fs[] =
		"\n"
		"#version 430\n"
		"\n"
		//"#extension GL_ARB_shader_storage_buffer_object : require\n"
		"\n"
		"const float PI = 3.14159265358979;\n"
		"const float FLT_EPSILON = 0.0000001192092896;\n"
		"\n"
		"uniform int LongitudeSlice;\n"
		"uniform int LatitudeSlice;\n"
		"uniform float LongitudeOverlap;\n"
		"uniform float StartAngle;\n"
		"uniform float CylinderHeight;\n"
		"uniform float Radius;\n"
		"uniform float TotalFOV;\n"
		"\n"
		"struct PlaneFunc{\n"
		"	vec3 normal;\n"
		"	vec3 point;\n"
		"};\n"
		"\n"
		"struct ProxyPlane{\n"
		"	PlaneFunc func;\n"
		"	vec3 boundary[4];\n"
		"};\n"
		"\n"
		"layout (std430, binding = 0) buffer BufferObject {\n"
		"	ProxyPlane planes[];\n"
		"};\n"
		"\n"
		"in vec2 tex_coord;\n"
		"\n"
		"layout (location = 0) out vec4 U1;\n"
		"layout (location = 1) out vec4 V1;\n"
		"layout (location = 2) out vec4 A1;\n"
		"layout (location = 3) out vec4 U2;\n"
		"layout (location = 4) out vec4 V2;\n"
		"layout (location = 5) out vec4 A2;\n"
		"\n"
		"struct IntersectionResult{\n"
		"	bool intersected;\n"
		"	vec2 uv;\n"
		"};\n"
		"\n"
		"IntersectionResult getSliceIntersection(int idx, vec3 p)\n"
		"{\n"
		"	IntersectionResult res;\n"
		"	vec3 eye = vec3(0.0, 0.0, 0.0);\n"
		"	vec3 dir = p - eye;\n"
		"\n"
		"	PlaneFunc pf = planes[idx].func;\n"
		"\n"
		"	float d = dot(pf.normal, eye - pf.point);\n"
		"	float rl = -dot(pf.normal, dir);\n"
		"\n"
		"	float t = d / rl;\n"
		"\n"
		"	vec3 r = eye + (dir * t);\n"
		"\n"
		"	vec3 glb = planes[idx].boundary[0];\n"
		"	vec3 glt = planes[idx].boundary[1];\n"
		"	vec3 grb = planes[idx].boundary[2];\n"
		"	vec3 grt = planes[idx].boundary[3];\n"
		"\n"
		"	vec3 vX = grb - glb;\n"
		"	vec3 vY = glt - glb;\n"
		"	float dotX = dot(vX, vX);\n"
		"	float dotY = dot(vY, vY);\n"
		"\n"
		"	vec3 vP = r - glb;\n"
		"	float dotPX = dot(vP, vX);\n"
		"	float dotPY = dot(vP, vY);\n"
		"\n"
		"	float u = dotPX / dotX;\n"
		"	float v = dotPY / dotY;\n"
		"\n"
		"	res.intersected = (u >= (0.0 - FLT_EPSILON) && u <= (1.0 + FLT_EPSILON)) && (v >= (0.0 - FLT_EPSILON) && v <= (1.0 + FLT_EPSILON));\n"
		"\n"
		"	u = clamp(u, 0.0, 1.0);\n"
		"	v = clamp(v, 0.0, 1.0);\n"
		"	res.uv.x = u;\n"
		"	res.uv.y = v;\n"
		"\n"
		"	return res;\n"
		"}\n"
		"\n"
		"vec4 GetPixelData(float data) {\n"
		"	int fi = int(data * 10000000.0);\n"
		"\n"
		"	int b[4];\n"
		"\n"
		"	b[3] = fi % 10;\n"
		"	fi = fi / 10;\n"
		"	b[2] = fi % 100;\n"
		"	fi = fi / 100;\n"
		"	b[1] = fi % 100;\n"
		"	fi = fi / 100;\n"
		"	b[0] = fi % 100;\n"
		"\n"
		"	float f[4];\n"
		"\n"
		"	f[0] = b[0] / 255.0;\n"
		"	f[1] = b[1] / 255.0;\n"
		"	f[2] = b[2] / 255.0;\n"
		"	f[3] = b[3] / 255.0;\n"
		"\n"
		"	vec4 res = vec4(f[0], f[1], f[2], f[3]);"
		"	return res;\n"
		"}\n"
		"\n"
		"void main(void)\n"
		"{\n"
		"	float perFOV = TotalFOV / LongitudeSlice;\n"
		"	float sideU = 1.0 / LongitudeSlice;\n"
		"	float sideV = 1.0 / LatitudeSlice;\n"
		"	float u = tex_coord.x;\n"
		"	float v = tex_coord.y;\n"
		"	int sideUIdx = int(u / sideU);\n"
		"	int sideVIdx = int(v / sideV);\n"
		"	float offsetX = (u - (sideU * sideUIdx)) / sideU;\n"
		"	float offsetY = v;\n"
		"	bool overlappedL = false;\n"
		"	bool overlappedR = false;\n"
		"	if (offsetX * perFOV < LongitudeOverlap) {\n"
		"		overlappedL = true;\n"
		"	}\n"
		"	else if (offsetX * perFOV >(perFOV - LongitudeOverlap)) {\n"
		"		overlappedR = true;\n"
		"	}\n"
		"\n"
		"	vec3 pointOnCylinder = vec3(0.0, (v - 0.5) * CylinderHeight, 0.0);\n"
		"	float rAngle = StartAngle + u * TotalFOV;\n"
		"	float rRadian = radians(rAngle);\n"
		"	pointOnCylinder.x = -Radius * cos(rRadian);\n"
		"	pointOnCylinder.z = -Radius * sin(rRadian);\n"
		"\n"
		"	float finalU1 = 0.0;\n"
		"	float finalV1 = 0.0;\n"
		"	float finalA1 = 0.0;\n"
		"	float finalU2 = 0.0;\n"
		"	float finalV2 = 0.0;\n"
		"	float finalA2 = 0.0;\n"
		"\n"
		"	bool intersected = true;\n"
		"	if (overlappedL) {\n"
		"		int sideUIdx1 = sideUIdx;\n"
		"		int sideUIdx2 = sideUIdx - 1;\n"
		"		if (sideUIdx1 == 0) {\n"
		"			if (TotalFOV >= 360.0 - LongitudeOverlap - FLT_EPSILON) {\n"
		"				sideUIdx2 = LongitudeSlice - 1;\n"
		"			}\n"
		"			else {\n"
		"				sideUIdx2 = 0;\n"
		"			}\n"
		"		}\n"
		"\n"
		"		int idx1 = LatitudeSlice * sideUIdx1 + sideVIdx;\n"
		"		int idx2 = LatitudeSlice * sideUIdx2 + sideVIdx;\n"
		"\n"
		"		IntersectionResult r1 = getSliceIntersection(idx1, pointOnCylinder);\n"
		"		IntersectionResult r2 = getSliceIntersection(idx2, pointOnCylinder);\n"
		"		if (!(r1.intersected && r2.intersected)) {\n"
		"			intersected = false;\n"
		"		}\n"
		"		else {\n"
		"			finalU1 = (sideU * sideUIdx1) + (r1.uv.x / LongitudeSlice);\n"
		"			finalV1 = (sideV * sideVIdx) + (r1.uv.y / LatitudeSlice);\n"
		"\n"
		"			finalU2 = (sideU * sideUIdx2) + (r2.uv.x / LongitudeSlice);\n"
		"			finalV2 = (sideV * sideVIdx) + (r2.uv.y / LatitudeSlice);\n"
		"\n"
		"			finalA1 = (offsetX * perFOV + LongitudeOverlap) / (LongitudeOverlap * 2.0);\n"
		"			finalA2 = 1.0 - finalA1;\n"
		"		}\n"
		"	}\n"
		"	else if (overlappedR) {\n"
		"		int sideUIdx1 = sideUIdx;\n"
		"		int sideUIdx2 = sideUIdx + 1;\n"
		"		if (sideUIdx1 == LongitudeSlice - 1) {\n"
		"			if (TotalFOV >= 360.0 - LongitudeOverlap - FLT_EPSILON) {\n"
		"				sideUIdx2 = 0;\n"
		"			}\n"
		"			else {\n"
		"				sideUIdx2 = LongitudeSlice - 1;\n"
		"			}\n"
		"		}\n"
		"\n"
		"		int idx1 = LatitudeSlice * sideUIdx1 + sideVIdx;\n"
		"		int idx2 = LatitudeSlice * sideUIdx2 + sideVIdx;\n"
		"\n"
		"		IntersectionResult r1 = getSliceIntersection(idx1, pointOnCylinder);\n"
		"		IntersectionResult r2 = getSliceIntersection(idx2, pointOnCylinder);\n"
		"		if (!(r1.intersected && r2.intersected)) {\n"
		"			intersected = false;\n"
		"		}\n"
		"		else {\n"
		"			finalU1 = (sideU * sideUIdx1) + (r1.uv.x / LongitudeSlice);\n"
		"			finalV1 = (sideV * sideVIdx) + (r1.uv.y / LatitudeSlice);\n"
		"\n"
		"			finalU2 = (sideU * sideUIdx2) + (r2.uv.x / LongitudeSlice);\n"
		"			finalV2 = (sideV * sideVIdx) + (r2.uv.y / LatitudeSlice);\n"
		"\n"
		"			finalA1 = (((1.0 - offsetX) * perFOV) + LongitudeOverlap) / (LongitudeOverlap * 2.0);\n"
		"			finalA2 = 1.0 - finalA1;\n"
		"		}\n"
		"	}\n"
		"	else {\n"
		"		int idx = LatitudeSlice * sideUIdx + sideVIdx;\n"
		"		IntersectionResult r = getSliceIntersection(idx, pointOnCylinder);\n"
		"		if (!r.intersected) {\n"
		"			intersected = false;\n"
		"		}\n"
		"		else {\n"
		"			finalU1 = finalU2 = (sideU * sideUIdx) + (r.uv.x / LongitudeSlice);\n"
		"			finalV1 = finalV2 = (sideV * sideVIdx) + (r.uv.y / LatitudeSlice);\n"
		"\n"
		"			finalA1 = finalA2 = 0.5;\n"
		"		}\n"
		"	}\n"
		"\n"
		"	if (!intersected) {\n"
		"		finalU1 = 2.0;\n"
		"		finalV1 = 2.0;\n"
		"		finalA1 = 2.0;\n"
		"		finalU2 = 2.0;\n"
		"		finalV2 = 2.0;\n"
		"		finalA2 = 2.0;\n"
		"	}\n"
		"\n"
		"	U1 = GetPixelData(finalU1);\n"
		"	V1 = GetPixelData(finalV1);\n"
		"	A1 = GetPixelData(finalA1);\n"
		"	U2 = GetPixelData(finalU2);\n"
		"	V2 = GetPixelData(finalV2);\n"
		"	A2 = GetPixelData(finalA2);\n"
		"\n"
		"}\n";

}
